
<instructions>

## 変換時の基本方針

• PostgreSQL バージョン15で実行可能な完全で構文的に正しいコードを出力します
• スキーマ名とオブジェクト名を小文字に変換し、SQLキーワードは大文字を維持します
• PL/SQL構文をPL/pgSQL構文に適切に変換します
• 元のコードからのコメントを保持します
• PostgreSQLは関数内でのトランザクション制御（COMMIT、ROLLBACK）を許可していないため：
  - 関数からトランザクション制御コードを削除します
  - 「トランザクション制御は呼び出し元のコードで実装する必要があります」コメントを追加します
• PostgreSQLは関数のネストをサポートしていないため：
  • すべての内部関数を別個の独立した関数として定義します
  • メインの手続きから呼び出す構造に変更します

### テスト考慮事項
• Oracle環境、PostgreSQL環境に変換対象のオブジェクトが参照するテーブルや索引があるか確認します
• 存在する場合は新たにDDLを作成するのではなく、それら表や索引といったオブジェクトを利用します。またそれらオブジェクトはDROPしないようにします

### データ型・関数マッピング
• **データ型変換**：VARCHAR2 → VARCHAR
• **関数変換**：
  • NVL → COALESCE
  • DECODE → CASE
  • SYSDATE → CURRENT_TIMESTAMP

## データ型変換
- OracleのRECORD型またはTYPE宣言の場合：
  * これらを抽出し、PostgreSQLの別個のCREATE TYPE文に変換する
  * これらのCREATE TYPE文をプロシージャ/関数定義の前に配置する
  * 再定義時の競合を避けるため、`CREATE TYPE`の前に常に`DROP TYPE IF EXISTS [type_name] CASCADE;`を使用する
  * 例：
    Oracle: 
      `TYPE my_record_type IS RECORD (id NUMBER, name VARCHAR2(100));` 
      （プロシージャ内）
    PostgreSQL: 
      ```sql
      DROP TYPE IF EXISTS my_record_type CASCADE;
      CREATE TYPE my_record_type AS (id numeric, name varchar(100));
      ```
      （プロシージャの前）

## 戻り値の処理
- PostgreSQLではOUTパラメータとRETURN文を同時に使用できない。以下のいずれかの方法で値を返す：
    * OUTパラメータを使用する場合：
        * 関数定義でOUT parameter_name data_typeと宣言する
        * 関数内でparameter_name := valueを割り当てる
        * RETURNS句は不要（またはRETURNS voidを使用）
        * 関数内でRETURN文を使用しない
    * RETURN文を使用する場合：
        * 関数定義でRETURNS data_typeと宣言する
        * 関数内でRETURN valueを使用する
        * OUTパラメータを使用しない

## ファイル操作とエラー処理
- OracleのUTL_FILEによるファイル読み書きには、Aurora PostgreSQLに対応する機能がない。ファイル操作はアプリケーション層で処理されると想定し、ストアドプロシージャがファイル出力に必要なデータを返すようにする。
- OracleのUTL_FILE関連の例外処理については、PostgreSQLには対応する機能がないため、以下の例のように詳細なエラー情報を収集して表示する：
    ```Oracle
    EXCEPTION
    WHEN UTL_FILE.INVALID_PATH THEN
    dbms_output.put_line('UTL_FILE.INVALID_PATH:' || TO_CHAR(SYSDATE,'YY/MM/DD HH24:MI:SS'));
    UTL_FILE.FCLOSE_ALL;
    WHEN UTL_FILE.INVALID_OPERATION THEN
    dbms_output.put_line('UTL_FILE.INVALID_OPERATION:' || TO_CHAR(SYSDATE,'YY/MM/DD HH24:MI:SS'));
    UTL_FILE.FCLOSE_ALL;
    WHEN OTHERS THEN --予期せぬエラー
    dbms_output.put_line('('||W_ORDERNO||')');
    dbms_output.put_line('処理件数 IN:' || to_char(i) || ' OUT:' || to_char(j)) ;
    dbms_output.put_line('OTHERS:' || SQLERRM || TO_CHAR(SYSDATE,'YY/MM/DD HH24:MI:SS'));
    UTL_FILE.FCLOSE_ALL;
    RAISE_APPLICATION_ERROR((-20000), '統計用 工事リスト ファイル作成 エラー');
    ```
    ```PostgreSQL
    EXCEPTION
        WHEN OTHERS THEN
            -- エラーコンテキストを取得
            GET STACKED DIAGNOSTICS error_context = PG_EXCEPTION_CONTEXT;
            
            -- エラー情報を出力
            RAISE NOTICE 'エラー発生:';
            RAISE NOTICE 'エラーコード: %', SQLSTATE;
            RAISE NOTICE 'エラーメッセージ: %', SQLERRM;
            RAISE NOTICE 'エラーコンテキスト: %', error_context;
            RAISE NOTICE '処理件数 IN: % OUT: %', i, j;
            RAISE NOTICE '最後に処理したオーダー: %', w_orderno;
            
            -- クリーンアップ処理
            RAISE NOTICE 'ファイルクローズ処理（シミュレーション）';
            
            -- エラーを再スローする（オプション）
            -- RAISE;
    ```

</instructions>

